## 10장. 객체지향 쿼리 언어

* JPQL이란?
    - JPA 표준에서 제공하는 객체지향 쿼리 언어
    - Entity 객체 기준으로 데이터를 질의
    - SQL처럼 보이지만 DB 테이블/컬럼이 아닌 엔티티/필드를 사용한다
    - JPA가 JPQL을 해석하여 `실제 SQL로 변환` 후 DB에 보낸다

* JPQL 기본문법
    - SELECT 문법
    ```java
    String jpql = "SELECT m FROM Member m WHERE m.age > 20";
    List<Member> members = em.createQuery(jpql, Member.class)
                            .getResultList();

    // Member : 엔티티 클래스명
    // m : 엔티티의 별칭
    // m.age : 엔티티의 필드명
    ```

    - 파라미터 바인딩
        + 이름 기반 바인딩
        ```java
        String jpql = "SELECT m FROM Member m WHERE m.name = :name";
        List<Member> result = em.createQuery(jpql, Member.class)
                            .setParameter("name", "강선구")
                            .getResultList();
        ```

        + 위치 기반 바인딩
        ```java
        String jpql = "SELECT m FROM Member m WHERE m.name = ?1 AND m.age = ?2";
        List<Member> result = em.createQuery(jpql, Member.class)
            .setParameter(1, "강선구")
            .setParameter(2, 30)
            .getResultList();
        ```

    - 프로젝션(projection)
        + 엔티티 프로젝션 : 엔티티 객체를 반환
        ```java
        String jpql = "SELECT m FROM Member m";
        List<Member> result = em.createQuery(jpql, Member.class).getResultList();

        // Member 엔티티를 반환
        ```

        + 스칼라(Scalar) 프로젝션
        ```java
        String jpql = "SELECT m.name FROM Member m";
        List<String> names = em.createQuery(jpql, String.class).getResultList();

        String jpql = "SELECT m.name, m.age FROM Member m";
        List<Object[]> result = em.createQuery(jpql).getResultList();
        for (Object[] row : result) {
            String name = (String) row[0];
            Integer age = (Integer) row[1];
        }
        ```

        + DTO 프로젝션 : DTO 객체로 매핑해서 반환
        ```java
        String jpql = "SELECT new com.example.dto.MemberDto(m.name, m.age) FROM Member m";
        List<MemberDto> dtos = em.createQuery(jpql, MemberDto.class).getResultList();

        // DTO 객체 안에 파라미터 순서 타입과 맞는 생성자가 필요
        ```

        + 임베디드 프로젝션
        ```java
        String jpql = "SELECT m.address FROM Member m";
        List<Address> addresses = em.createQuery(jpql, Address.class).getResultList();

        // 임베디드 타입을 반환한다
        ```

        | 프로젝션 종류  | 특징      | 장점                 | 단점/주의사항                         |
        | -------- | ---------------------------------- | ------------------ | ------------------------------- |
        | 엔티티      | 엔티티 객체 그대로 반환                      | 관리 편함, 엔티티 직접 사용   | Lazy 로딩, N+1 문제, 불필요한 데이터 포함 가능 |
        | 단일/다중 필드 | 일부 값만 추출 (String, Object\[], etc.) | 가볍고 빠름             | 여러 컬럼이면 Object\[] → 타입 안전성 낮음   |
        | DTO(new) | DTO로 직접 매핑                         | 타입 안전, 필요한 데이터만 전달 | 생성자 필요, 필드명·타입 순서 주의            |
        | 임베디드 타입  | 임베디드(내장) 타입 반환                     | 복합 값 객체 직접 반환 가능   | -                               |

* 타입 쿼리와 일반 쿼리
    - TypedQuery
        + 제네릭 기반으로 반환 타입을 명확하게 지정
        + createQuery(jpql, 반환타입.class)
        + 반환값이 엔티티, 단일속성, DTO 등 명확할 때 사용
        ```java
        String jpql = "SELECT m FROM Member m WHERE m.name = :name";
        TypedQuery<Member> query = em.createQuery(jpql, Member.class);
        query.setParameter("name", "강선구");
        List<Member> result = query.getResultList();
        ```

    - Query
        + 반환 타입이 미지정
        + 반환 타입이 여러개(여러 필드, 여러 타입, Object[] 등)
        ```java
        String jpql = "SELECT m.name, m.age FROM Member m";
        Query query = em.createQuery(jpql);
        List<Object[]> result = query.getResultList();
        for (Object[] row : result) {
            String name = (String) row[0];
            Integer age = (Integer) row[1];
        }
        ```

        | 구분    | TypedQuery<T>         | Query               |
        | ----- | --------------------- | ------------------- |
        | 타입    | 반환 타입 명확 (제네릭 지정)     | 반환 타입 미정 (Object 등) |
        | 안전성   | 컴파일 타임에 타입 체크         | 런타임에 캐스팅 필요         |
        | 반환 예시 | Member, String, DTO 등 | Object\[], Object   |
        | 사용 권장 | 가능하면 TypedQuery 사용    | 복합 결과 등 불가피할 때      |

* 페이징
    - setFirstResult(int startPosition)
        + 0부터 시작, (pageNumber - 1) * pageSize
    - setMaxResults(int maxResult)
        + 한번에 가져올 데이터의 개수(페이지 크기)
    ```java
    String jpql = "SELECT m FROM Member m ORDER BY m.id DESC";
    List<Member> result = em.createQuery(jpql, Member.class)
        .setFirstResult(0)  // 시작 위치(0부터)
        .setMaxResults(10)  // 가져올 개수(페이지 크기)
        .getResultList();
    ```