## 15장. 고급 주제와 성능 최적화

### 예외 처리
JPA 표준 예외들은 javax.persistence.PersistenceException의 자식 클래스다.
그리고 이 예외 클래스는 RuntimeException의 자식이다. 따라서 JPA 예외는 언체크 예외다.
언체크 예외는 컴파일 시점에서 예외 처리를 강제하지 않으므로 조심해야 한다.

JPA의 표준 예외는 크게 2가지로 나눌 수 있다.

+ 트랜잭션 롤백을 표시하는 예외
+ 트랜잭션 롤백을 표시하지 않는 예외

트랜잭션 롤백을 표시하는 예외는 심각한 예외이므로 트랜잭션을 강제로 커밋해도 트랜잭션이 커밋되지 않고
javax.persistence.RollbackException 예외가 발생한다

* 주요 JPA 예외들
아래는 트랜잭션 롤백을 표시하는 예외다.
엔티티 관련 예외
+ EntityExistsException : 이미 존재하는 엔티티를 persist()할 때
+ EntityNotFoundException : 존재하지 않는 엔티티에 접근할 때

락킹 관련 예외
+ OptimisticLockException : 낙관적 락 충돌 시
+ PessimisticLockException : 비관적 락 획득 실패 시
+ LockTimeoutException : 락 획득 대기 시간 초과 시

트랜잭션 관련 예외
+ TransactionRequiredException : 트랜잭션이 필요한 작업을 트랜잭션 없이 수행할 때

다음은 트랜잭션 롤백을 표시하지 않는 예외다
쿼리 관련 예외
+ NoResultException : getSingleResult()에서 결과가 없을 때
+ NonUniqueResultException : getSingleResult()에서 결과가 여러개일 때
+ QueryTimeoutException : 쿼리 실행 결과가 초과될 때

### 트랜잭션 롤백 시 주의사항
트랜잭션을 롤백하는 것은 데이터베이스의 반영사항만 롤백하는 것이지 수정한 자바 객체까지 롤백하지 않는다. 
트랜잭션을 롤백하면 데이터베이스의 데이터는 복구되지만 객체는 수정된 상태 그대로 영속성 컨텍스트에 남아있다. 
따라서 트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다.

기본적으로 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료하므로 문제가 발생하지 않는다. 
문제는 OSIV처럼 영속성 컨텍스트의 범위를 트랜잭션 범위보다 넓게 사용할 때, 발생한다.

### 엔티티 비교

* 영속성 컨텍스트가 같을 때
1차 캐시가 동일성을 보장하기 때문에 동일한 ID의 엔티티에 대해서는 `항상 같은 객체 참조`를 반환함

```java
// 같은 EntityManager 사용
EntityManager em = entityManagerFactory.createEntityManager();

User user1 = em.find(User.class, 1L);
User user2 = em.find(User.class, 1L);

System.out.println(user1 == user2); // true - 동일한 객체 참조
System.out.println(user1.equals(user2)); // true (보통)


EntityManager em = entityManagerFactory.createEntityManager();

// 첫 번째 조회 - DB에서 조회 후 1차 캐시에 저장
User user1 = em.find(User.class, 1L);

// 두 번째 조회 - 1차 캐시에서 반환 (DB 접근 없음)
User user2 = em.find(User.class, 1L);

// 세 번째 조회 - JPQL로 조회해도 같은 객체
User user3 = em.createQuery("SELECT u FROM User u WHERE u.id = 1", User.class)
               .getSingleResult();

System.out.println(user1 == user2); // true
System.out.println(user1 == user3); // true
System.out.println(user2 == user3); // true
```

따라서 영속성 컨텍스트가 같으면 엔티티를 비교할 때, 다음 3가지 조건을 모두 만족한다.
1. 동일성 : == 비교가 같다
2. 동등성 : equals() 비교가 같ㄴ다
3. 데이터베이스 동등성 : @Id인 식별자가 같다.

* 영속성 컨텍스트가 다를 때
다른 영속성 컨텍스트에서는 같은 ID의 엔티티라도 `서로 다른 객체`가 된다

```java
// 첫 번째 EntityManager
EntityManager em1 = entityManagerFactory.createEntityManager();
User user1 = em1.find(User.class, 1L);

// 두 번째 EntityManager  
EntityManager em2 = entityManagerFactory.createEntityManager();
User user2 = em2.find(User.class, 1L);

System.out.println(user1 == user2); // false - 서로 다른 객체
System.out.println(user1.equals(user2)); // equals 구현에 따라 다름
```

따라서, equals()와 hashcode()의 구현이 중요하다.

```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    // equals, hashCode 구현 없음 - Object의 기본 구현 사용
}

// 다른 영속성 컨텍스트에서
User user1 = em1.find(User.class, 1L);
User user2 = em2.find(User.class, 1L);

Set<User> userSet = new HashSet<>();
userSet.add(user1);
userSet.add(user2);
System.out.println(userSet.size()); // 2 - 논리적으로는 같은 엔티티인데!
```

1. 동일성 : == 비교가 실패한다.
2. 동등성 : equals() 비교가 만족한다. 다만, equals()를 구현해야 한다
3. 데이터베이스 동등성 : @Id인 식별자가 같다

### 프록시
프록시는 원본 엔티티를 상속하여 만들어지므로 엔티티를 사용하는 클라이언트는 엔티티가 원본 엔티티인지 프록시인지 구별하지 않아도 된다.

영속성 컨텍스트는 영속 엔티티의 동일성을 보장한다.

```java
EntityManager em = entityManagerFactory.createEntityManager();

// 시나리오 1: 실제 엔티티가 먼저 1차 캐시에 있는 경우
User proxy = em.getReference(User.class, 1L); // 실제 엔티티 반환 (프록시 X)
User realUser = em.find(User.class, 1L); // 실제 엔티티

System.out.println(realUser == proxy); // true - 같은 객체
System.out.println(proxy.getClass()); // User (프록시가 아님)
```

영속 엔티티의 동일성을 보장하기 위해서는 프록시와 실제 엔티티가 같은 엔티티여야 한다.
그래서 영속성 컨텍스트는 프록시로 조회한 엔티티에 대해서 같은 엔티티를 호출하면 원본 엔티티가 아닌 처음 조회한 프록시를 반환한다.

반대로 원본 엔티티를 먼저 조회하면? 
원본 엔티티를 먼저 조회하면 영속성 컨텍스트는 원본 엔티티를 이미 데이터베이스에서 조회했으므로 프록시를 반환할 이유가 없다

### 프록시와 상속
```java
// Book 엔티티를 저장
Book book = new Book();
book.setName("JPA 교과서");
book.setAuthor("김영한");
entityManager.persist(book);
entityManager.flush();
entityManager.clear();

// 부모 타입으로 프록시 조회
Item item = entityManager.getReference(Item.class, book.getId());
System.out.println(item.getClass()); // Item$HibernateProxy$ (Item 타입의 프록시)

// 다운캐스팅 시도
Book bookProxy = (Book) item; // ClassCastException 발생!
```

`프록시는 조회한 타입을 기준`으로 생성된다. getReference(Item.class, id)로 조회하면 Item 타입의 프록시가 생성되고, 실제 데이터베이스의 데이터가 Book이어도 엔티티는 Item으로 생성된다. 따라서 ClassCastException이 발생한다.

해결방법은 아래와 같다.

+ 실제 타입으로 조회
```java
// 올바른 방법: 실제 타입으로 조회
Book book = entityManager.getReference(Book.class, bookId);
System.out.println(book.getAuthor()); // 정상 작동
```

+ JPQL 사용
```java
// JPQL로 구체 타입 조회
Book book = entityManager.createQuery(
    "SELECT b FROM Book b WHERE b.id = :id", Book.class)
    .setParameter("id", bookId)
    .getSingleResult();
```

+ 프록시 초기화 후 실제 타입 확인
```java
Item item = entityManager.getReference(Item.class, bookId);

// 프록시 강제 초기화
Hibernate.initialize(item);

// 실제 타입 확인 (Hibernate 전용)
if (item instanceof HibernateProxy) {
    HibernateProxy proxy = (HibernateProxy) item;
    LazyInitializer li = proxy.getHibernateLazyInitializer();
    Object implementation = li.getImplementation();
    
    if (implementation instanceof Book) {
        Book book = (Book) implementation;
        System.out.println(book.getAuthor());
    }
}
```