## 15장. 고급 주제와 성능 최적화

### 예외 처리
JPA 표준 예외들은 javax.persistence.PersistenceException의 자식 클래스다.
그리고 이 예외 클래스는 RuntimeException의 자식이다. 따라서 JPA 예외는 언체크 예외다.
언체크 예외는 컴파일 시점에서 예외 처리를 강제하지 않으므로 조심해야 한다.

JPA의 표준 예외는 크게 2가지로 나눌 수 있다.

+ 트랜잭션 롤백을 표시하는 예외
+ 트랜잭션 롤백을 표시하지 않는 예외

트랜잭션 롤백을 표시하는 예외는 심각한 예외이므로 트랜잭션을 강제로 커밋해도 트랜잭션이 커밋되지 않고
javax.persistence.RollbackException 예외가 발생한다

* 주요 JPA 예외들
아래는 트랜잭션 롤백을 표시하는 예외다.
엔티티 관련 예외
+ EntityExistsException : 이미 존재하는 엔티티를 persist()할 때
+ EntityNotFoundException : 존재하지 않는 엔티티에 접근할 때

락킹 관련 예외
+ OptimisticLockException : 낙관적 락 충돌 시
+ PessimisticLockException : 비관적 락 획득 실패 시
+ LockTimeoutException : 락 획득 대기 시간 초과 시

트랜잭션 관련 예외
+ TransactionRequiredException : 트랜잭션이 필요한 작업을 트랜잭션 없이 수행할 때

다음은 트랜잭션 롤백을 표시하지 않는 예외다
쿼리 관련 예외
+ NoResultException : getSingleResult()에서 결과가 없을 때
+ NonUniqueResultException : getSingleResult()에서 결과가 여러개일 때
+ QueryTimeoutException : 쿼리 실행 결과가 초과될 때

### 트랜잭션 롤백 시 주의사항
트랜잭션을 롤백하는 것은 데이터베이스의 반영사항만 롤백하는 것이지 수정한 자바 객체까지 롤백하지 않는다. 
트랜잭션을 롤백하면 데이터베이스의 데이터는 복구되지만 객체는 수정된 상태 그대로 영속성 컨텍스트에 남아있다. 
따라서 트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다.

기본적으로 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료하므로 문제가 발생하지 않는다. 
문제는 OSIV처럼 영속성 컨텍스트의 범위를 트랜잭션 범위보다 넓게 사용할 때, 발생한다.

### 엔티티 비교

* 영속성 컨텍스트가 같을 때
1차 캐시가 동일성을 보장하기 때문에 동일한 ID의 엔티티에 대해서는 `항상 같은 객체 참조`를 반환함

```java
// 같은 EntityManager 사용
EntityManager em = entityManagerFactory.createEntityManager();

User user1 = em.find(User.class, 1L);
User user2 = em.find(User.class, 1L);

System.out.println(user1 == user2); // true - 동일한 객체 참조
System.out.println(user1.equals(user2)); // true (보통)


EntityManager em = entityManagerFactory.createEntityManager();

// 첫 번째 조회 - DB에서 조회 후 1차 캐시에 저장
User user1 = em.find(User.class, 1L);

// 두 번째 조회 - 1차 캐시에서 반환 (DB 접근 없음)
User user2 = em.find(User.class, 1L);

// 세 번째 조회 - JPQL로 조회해도 같은 객체
User user3 = em.createQuery("SELECT u FROM User u WHERE u.id = 1", User.class)
               .getSingleResult();

System.out.println(user1 == user2); // true
System.out.println(user1 == user3); // true
System.out.println(user2 == user3); // true
```

따라서 영속성 컨텍스트가 같으면 엔티티를 비교할 때, 다음 3가지 조건을 모두 만족한다.
1. 동일성 : == 비교가 같다
2. 동등성 : equals() 비교가 같ㄴ다
3. 데이터베이스 동등성 : @Id인 식별자가 같다.

* 영속성 컨텍스트가 다를 때
다른 영속성 컨텍스트에서는 같은 ID의 엔티티라도 `서로 다른 객체`가 된다

```java
// 첫 번째 EntityManager
EntityManager em1 = entityManagerFactory.createEntityManager();
User user1 = em1.find(User.class, 1L);

// 두 번째 EntityManager  
EntityManager em2 = entityManagerFactory.createEntityManager();
User user2 = em2.find(User.class, 1L);

System.out.println(user1 == user2); // false - 서로 다른 객체
System.out.println(user1.equals(user2)); // equals 구현에 따라 다름
```

따라서, equals()와 hashcode()의 구현이 중요하다.

```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    // equals, hashCode 구현 없음 - Object의 기본 구현 사용
}

// 다른 영속성 컨텍스트에서
User user1 = em1.find(User.class, 1L);
User user2 = em2.find(User.class, 1L);

Set<User> userSet = new HashSet<>();
userSet.add(user1);
userSet.add(user2);
System.out.println(userSet.size()); // 2 - 논리적으로는 같은 엔티티인데!
```

1. 동일성 : == 비교가 실패한다.
2. 동등성 : equals() 비교가 만족한다. 다만, equals()를 구현해야 한다
3. 데이터베이스 동등성 : @Id인 식별자가 같다

### 프록시
프록시는 원본 엔티티를 상속하여 만들어지므로 엔티티를 사용하는 클라이언트는 엔티티가 원본 엔티티인지 프록시인지 구별하지 않아도 된다.

영속성 컨텍스트는 영속 엔티티의 동일성을 보장한다.

```java
EntityManager em = entityManagerFactory.createEntityManager();

// 시나리오 1: 실제 엔티티가 먼저 1차 캐시에 있는 경우
User proxy = em.getReference(User.class, 1L); // 실제 엔티티 반환 (프록시 X)
User realUser = em.find(User.class, 1L); // 실제 엔티티

System.out.println(realUser == proxy); // true - 같은 객체
System.out.println(proxy.getClass()); // User (프록시가 아님)
```

영속 엔티티의 동일성을 보장하기 위해서는 프록시와 실제 엔티티가 같은 엔티티여야 한다.
그래서 영속성 컨텍스트는 프록시로 조회한 엔티티에 대해서 같은 엔티티를 호출하면 원본 엔티티가 아닌 처음 조회한 프록시를 반환한다.

반대로 원본 엔티티를 먼저 조회하면? 
원본 엔티티를 먼저 조회하면 영속성 컨텍스트는 원본 엔티티를 이미 데이터베이스에서 조회했으므로 프록시를 반환할 이유가 없다

### 프록시와 상속

```java
// 1. 상품 도메인
Item item = findItem(itemId); // Book일까? Movie일까? Album일까?

// 2. 결제 도메인  
Payment payment = findPayment(paymentId); // CardPayment? BankTransfer? CashPayment?

// 3. 할인 도메인
DiscountPolicy policy = findPolicy(policyId); // RateDiscount? FixDiscount?
```
> 왜 이런 도메인에서 문제가 발생할까?

`프록시는 조회한 타입을 기준`으로 생성된다. getReference(Item.class, id)로 조회하면 Item 타입의 프록시가 생성되고, 실제 데이터베이스의 데이터가 Book이어도 엔티티는 Item으로 생성된다. 즉, 프록시를 부모 타입으로 조회하면 부모의 타입을 기반으로 하는 프록시가 생성된다.

```java
// 주문 서비스에서
@Service
public class OrderService {
    
    public void processOrder(Long itemId) {
        // 이 시점에는 Book인지 Movie인지 모름
        Item item = itemRepository.findById(itemId); // 부모 타입으로 조회
        
        // 비즈니스 로직에서 구체 타입별 처리가 필요
        if (item instanceof Book) {
            Book book = (Book) item;
            // 책 특화 로직 (재고 확인, 출판사 연락 등)
            checkBookStock(book);
        } else if (item instanceof Movie) {
            Movie movie = (Movie) item;  
            // 영화 특화 로직 (상영관 예약 등)
            reserveTheater(movie);
        }
    }
}

// 프록시 문제 발생
// Repository에서 getReference 사용 시
public Item findById(Long id) {
    return entityManager.getReference(Item.class, id); // Item 타입 프록시 생성
}

// 서비스에서 사용할 때
Item item = itemRepository.findById(bookId); // Item 프록시 반환
if (item instanceof Book) { // false! (Book이 아닌 Item 프록시)
    // 이 블록은 실행되지 않음
}
```

왜 다형성 도메인에서만 문제가 될까?

```java
// Item은 Book, Movie, Album의 부모
Item item = entityManager.getReference(Item.class, itemId);
// Item 프록시인데 실제로는 Book의 기능이 필요함
Book book = (Book) item; // ClassCastException!
```

해결방법은 아래와 같다.

+ 실제 타입으로 조회
```java
// 올바른 방법: 실제 타입으로 조회
Book book = entityManager.getReference(Book.class, bookId);
System.out.println(book.getAuthor()); // 정상 작동
```

+ JPQL 사용
```java
// JPQL로 구체 타입 조회
Book book = entityManager.createQuery(
    "SELECT b FROM Book b WHERE b.id = :id", Book.class)
    .setParameter("id", bookId)
    .getSingleResult();
```

+ 프록시 초기화 후 실제 타입 확인
```java
Item item = entityManager.getReference(Item.class, bookId);

// 프록시 강제 초기화
Hibernate.initialize(item);

// 실제 타입 확인 (Hibernate 전용)
if (item instanceof HibernateProxy) {
    HibernateProxy proxy = (HibernateProxy) item;
    LazyInitializer li = proxy.getHibernateLazyInitializer();
    Object implementation = li.getImplementation();
    
    if (implementation instanceof Book) {
        Book book = (Book) implementation;
        System.out.println(book.getAuthor());
    }
}
```

+ 비지터 패턴 사용
    - 비지터 패턴을 사용하는 이유 : 다운캐스팅없이 각 타입별 로직을 실행할 수 있다

    1. 비지터 패턴 기본 구조
    ```java
    public interface ItemVisitor {
        void visit(Book book);
        void visit(Movie movie);
        void visit(Album album);
    }
    ```

    2. 엔티티에 accept() 메서드 추가
    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    public abstract class Item {
        @Id @GeneratedValue
        private Long id;
        private String name;
        private int price;
        
        // 비지터 패턴의 핵심 메서드
        public abstract void accept(ItemVisitor visitor);
    }

    @Entity
    public class Book extends Item {
        private String author;
        private String isbn;
        
        @Override
        public void accept(ItemVisitor visitor) {
            visitor.visit(this); // Book 타입으로 자동 전달
        }
    }

    @Entity
    public class Movie extends Item {
        private String director;
        private String actor;
        
        @Override
        public void accept(ItemVisitor visitor) {
            visitor.visit(this); // Movie 타입으로 자동 전달
        }
    }
    ```

    3. 실제 사용 예시
    + 배송비 계산 Visitor
    ```java
    public class DeliveryFeeCalculator implements ItemVisitor {
        private double fee = 0;
        
        @Override
        public void visit(Book book) {
            this.fee = 2500; // 책 배송비
        }
        
        @Override
        public void visit(Movie movie) {
            this.fee = 0; // 디지털 배송
        }
        
        @Override
        public void visit(Album album) {
            this.fee = 3000; // 앨범 배송비
        }
        
        public double getFee() {
            return fee;
        }
    }
    ```

    + 프록시와 함께 사용하기
    ```java
    @Service
    public class OrderService {
        
        public void processOrder(Long itemId) {
            // Item 프록시로 조회 (Book인지 Movie인지 모름)
            Item item = entityManager.getReference(Item.class, itemId);
            
            // 배송비 계산 - 다운캐스팅 없이!
            DeliveryFeeCalculator calculator = new DeliveryFeeCalculator();
            item.accept(calculator); // 프록시여도 정상 작동
            double fee = calculator.getFee();
            
            // 상품 정보 출력
            ItemInfoPrinter printer = new ItemInfoPrinter();
            item.accept(printer); // 각 타입별 정보 출력
            
            System.out.println("배송비: " + fee + "원");
        }
    }
    ```

    + 장점
        - 타입 안정성 : instarnceof나 다운캐스팅이 불필요  
        ```java
        // instanceof나 다운캐스팅 불필요
        if (item instanceof Book) {        // 이런 코드가
            Book book = (Book) item;       // 필요 없어짐
            // book 로직
        }

        // 대신 이렇게
        item.accept(visitor); // 컴파일 타임에 타입 안전성 보장
        ```

        - 새로운 기능 추가가 쉬움 : 새로운 기능이 필요할 때마다 새로운 Visitor만 추가

        - 프록시와 완벽 호환
        ```java
        // 프록시든 실제 엔티티든 상관없이 동작
        Item proxy = entityManager.getReference(Item.class, bookId);
        Item real = entityManager.find(Item.class, movieId);

        TaxCalculator taxCalc = new TaxCalculator();
        proxy.accept(taxCalc); // 정상 작동
        real.accept(taxCalc);  // 정상 작동
        ```

    + 단점
        - 새로운 타입 추가시 모든 Visitor를 수정
        - 순환 참조 문제가 발생할 가능성이 존재 : Visitor가 엔티티를 참조하고 엔티티가 Visitor를 참조

### 성능 최적화
+ N+1 문제  
    - 1번의 쿼리를 실행했는데, 연관된 데이터를 조회하기 위해 추가로 N번의 쿼리가 실행되는 문제
    - 기본 상황 설정
        ```java
        @Entity
        public class Team {
            @Id @GeneratedValue
            private Long id;
            private String name;
            
            @OneToMany(mappedBy = "team", fetch = FetchType.LAZY)
            private List<Member> members = new ArrayList<>();
        }

        @Entity  
        public class Member {
            @Id @GeneratedValue
            private Long id;
            private String username;
            
            @ManyToOne(fetch = FetchType.LAZY)
            @JoinColumn(name = "team_id")
            private Team team;
        }
        ```

    - 즉시 로딩(EAGER)에서 발생
        ```java
        @Entity
        public class Member {
            @ManyToOne(fetch = FetchType.EAGER) // 즉시 로딩
            private Team team;
        }

        // 실행
        List<Member> members = entityManager
            .createQuery("SELECT m FROM Member m", Member.class)
            .getResultList();

        // 실행되는 쿼리:
        // 1. SELECT m FROM Member m        (1번 쿼리)
        // 2. SELECT t FROM Team t WHERE t.id = ?  (N번 쿼리 - 각 회원의 팀 조회)
        // 3. SELECT t FROM Team t WHERE t.id = ?
        // 4. SELECT t FROM Team t WHERE t.id = ?
        // ... (회원 수만큼 반복)
        ```

    - 지연 로딩(LAZY)에서 발생
        ```java
        @Entity
        public class Team {
            @OneToMany(mappedBy = "team", fetch = FetchType.LAZY) // 지연 로딩
            private List<Member> members;
        }

        // 실행
        List<Team> teams = entityManager
            .createQuery("SELECT t FROM Team t", Team.class)
            .getResultList(); // 1번 쿼리

        for (Team team : teams) {
            System.out.println("팀명: " + team.getName());
            System.out.println("회원 수: " + team.getMembers().size()); // N번 쿼리 발생
        }

        // 실행되는 쿼리:
        // 1. SELECT t FROM Team t                              (1번 쿼리)
        // 2. SELECT m FROM Member m WHERE m.team_id = ?        (N번 쿼리)
        // 3. SELECT m FROM Member m WHERE m.team_id = ?
        // ... (팀 수만큼 반복)
        ```

    - 해결방법
        - Fetch Join 사용
        ```java
        public interface TeamRepository extends JpaRepository<Team, Long> {
            
            @Query("SELECT t FROM Team t JOIN FETCH t.members")
            List<Team> findAllWithMembers();
        }
        ```

        - EntityGraph 사용
        ```java
        public interface TeamRepository extends JpaRepository<Team, Long> {
            
            @EntityGraph(attributePaths = {"members"})
            List<Team> findAll();
            
            @EntityGraph(attributePaths = {"members"})
            Optional<Team> findById(Long id);
        }
        ```
    
    - 정리
        - 지연 로딩과 즉시 로딩에서 모두 발생 가능
        - Fetch Join이 가장 일반적인 해결책
        - 기본 Lazy + 선택적 Fetch Join 권장
        - @OneToOne과 @ManyToOne은 기본값이 즉시 로딩이므로 꼭 지연 로딩으로 변경해주어야 한다

+ 읽기 전용 쿼리의 성능 최적화
    - 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 메모리를 많이 사용하는 단점이 존재
        - 단순히 데이터를 읽는 용도로 엔티티를 조회하는 경우, 스냅샷 인스턴스가 필요없다  
        이때는 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최소화할 수 있다

    - 스칼라 타입으로 조회
        - 전체 Entity 대신 필요한 데이터만 조회
        ```java
        // 비효율적: 전체 엔티티 조회
        @Query("SELECT m FROM Member m")
        List<Member> findAllMembers();

        // 효율적: 필요한 필드만 조회
        @Query("SELECT m.id, m.username, m.email FROM Member m")
        List<Object[]> findMemberSummary();

        // 더 좋은 방법: DTO로 조회
        @Query("SELECT new com.example.dto.MemberSummaryDto(m.id, m.username, m.email) FROM Member m")
        List<MemberSummaryDto> findMemberSummaryDto();
        ```

    - 읽기 전용 트랜잭션 사용
        - 플러시 모드를 MANUAL로 설정 : 불필요한 dirty checking 생략
        - 하이버네이트에서 읽기 전용 힌트 제공
        ```java
        @Service
        public class MemberService {
            
            @Transactional(readOnly = true)
            public List<Member> findAllMembers() {
                return memberRepository.findAll();
            }
            
            @Transactional(readOnly = true)
            public Member findById(Long id) {
                return memberRepository.findById(id)
                    .orElseThrow(() -> new EntityNotFoundException());
            }
        }
        ```

* 배치 처리
    - 여러 개의 데이터베이스 연산을 묶어서 한번에 실행하는 것을 배치라고 한다
        + 개별적으로 SQL을 실행하는 것보다 네트워크 왕복 횟수를 줄여 성능을 크게 향상시킬 수 있다
        + 영속성 컨텍스트에 데이터가 쌓이지 않도록 일정 단위마다 플러시 및 초기화 진행해야 한다

        ```yml
        spring:
          jpa:
            properties:
              hibernate:
                jdbc:
                  batch_size: 100          # 배치 크기 설정
                order_inserts: true        # INSERT 순서 정렬
                order_updates: true        # UPDATE 순서 정렬
                batch_versioned_data: true # 버전 관리 엔티티 배치 지원
        ```

        ```java
        @Service
        @Transactional
        public class UserBatchService {
            
            @Autowired
            private EntityManager entityManager;
            
            public void batchInsertUsers(List<User> users) {
                int batchSize = 100;
                
                for (int i = 0; i < users.size(); i++) {
                    entityManager.persist(users.get(i));
                    
                    // 배치 크기마다 flush와 clear 수행
                    if ((i + 1) % batchSize == 0) {
                        entityManager.flush();
                        entityManager.clear();
                    }
                }
                
                // 남은 데이터 처리
                entityManager.flush();
                entityManager.clear();
            }
        }
        ```