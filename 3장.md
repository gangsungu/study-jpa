## 3장. 영속성 관리

* 엔티티 매니저 팩토리와 엔티티 매니저
    - 엔티티 매니저는 엔티티를 저장, 수정, 삭제, 조회 등 엔티티와 관련된 모든 일을 처리한다<br/>
    > 개발자 입장에서 엔티티를 저장하는 가상의 DB로 생각해도 무방
    
    - 엔티티 매니저 팩토리는 엔티티 매니저를 생성하는 공장<br/>
    > 엔티티 매니저 팩토리가 한번 실행될 때마다 들어가는 리소스가 크기떄문에 애플리케이션 전체에서 하나만 생성

* JPA에서 영속이라는 표현을 사용하는 이유
    - 단순히 객체를 저장하는 것이 아닌 JPA가 해당 객체를 책임지고 추적하고, 변경사항을 자동 반영하기 때문

    | 개념       | 저장 (`save`)       | 영속 (`persist`)            |
    | -------- | ----------------- | ------------------------- |
    | 일반 의미    | 데이터를 디스크나 DB에 기록  | JPA가 객체를 영속성 컨텍스트에 등록     |
    | 예시       | 파일 저장, SQL INSERT | JPA의 `em.persist(entity)` |
    | 주체       | 개발자나 코드가 명령       | JPA가 내부적으로 관리             |
    | 객체 상태 추적 | 없음                | 있음 (변경 감지, 1차 캐시 등)       |
    | 대상       | 보통 DB             | 영속성 컨텍스트 (메모리)            |
    > 저장은 단발성 개념, 영속은 JPA가 해당 객체를 계속 추적, 관리하는 장기적인 관계를 의미

* 영속성 컨텍스트
    - 엔티티 객체를 저장(영속)하고 관리하는 JPA의 메모리 공간(1차 캐시)

    | 역할                         | 설명                                  |
    | -------------------------- | ----------------------------------- |
    | **엔티티 저장 및 관리**            | `persist()`로 등록한 엔티티를 **1차 캐시**에 저장 |
    | **엔티티 식별 및 동일성 보장**        | 같은 PK의 엔티티는 항상 같은 인스턴스를 보장          |
    | **변경 감지 (Dirty Checking)** | 엔티티 값이 바뀌면 자동으로 UPDATE 쿼리를 생성       |
    | **지연 로딩 지원**               | 프록시 객체를 통해 연관 엔티티를 필요할 때만 로딩        |
    | **flush 타이밍 제어**           | 트랜잭션 커밋 전 DB 반영 시점 조정 가능            |

    | 기능     | 설명                                 |
    | ------ | ---------------------------------- |
    | 1차 캐시  | 엔티티를 메모리에 저장하여 중복 조회 방지            |
    | 동일성 보장 | 같은 PK는 동일 객체 (== 비교 가능)            |
    | 변경 감지  | 값이 바뀌면 자동 UPDATE 생성                |
    | 쓰기 지연  | `persist()` 호출 후 실제 SQL은 커밋 시점에 실행 |
    | 상태 관리  | 비영속 → 영속 → 준영속/삭제 상태 관리            |

    ```java
    EntityManager em = emf.createEntityManager();
    em.getTransaction().begin();

    Member member = new Member("홍길동"); // 비영속
    em.persist(member); // 영속 상태, 1차 캐시에 등록

    member.setName("강감찬"); // 변경 감지 (Dirty Checking)

    em.getTransaction().commit(); // flush → update 쿼리 실행
    ```
    > persist() > 영속성 컨텍스트에 저장<br/>
    > setName() > JPA가 변경을 추적<br/>
    > commit() > 변경된 내용을 DB에 반영

    - 영속성 컨텍스트는 메모리 상의 1차 캐시
    ```java
    Member member = em.find(Member.class, 1L);
    // DB에서 가져오는 게 아니라 1차 캐시에서 먼저 찾음
    ```

    - 변경감지(Dirty Checking)
        + JPA는 트랜잭션 내에서 엔티티의 스냅샷을 기억
        + 트랜잭션 커밋 시점에 현재 상태와 비교하고 차이가 있으면 자동으로 update 쿼리를 생성

    - 쓰기 지연(write-behind)
    em.persist() 등의 호출시, 즉시 insert 쿼리를 날리는게 아닌 영속성 컨텍스트 내부의 쓰기 지연 저장소에 모아뒀다가 트랜잭션 커밋 시점에 한꺼번에 SQL을 실행하는 전략<br/>
    > persist()를 여러번 실행해도 DB에는 실제 반영되지 않음, commit() 또는 flush() 시점에 SQL이 실제로 실행됨

    ```java
    em.getTransaction().begin();

    Member m1 = new Member("A");
    Member m2 = new Member("B");

    em.persist(m1); // INSERT 쿼리 아직 실행되지 않음
    em.persist(m2); // INSERT 쿼리 아직 실행되지 않음

    // 여기까지는 INSERT 쿼리 X

    em.getTransaction().commit(); 
    // 이 시점에 INSERT 쿼리 2개가 DB에 날아감 (flush + commit)
    ```

    | 목적             | 설명                                                             |
    | -------------- | -------------------------------------------------------------- |
    | **성능 향상**      | INSERT, UPDATE, DELETE 쿼리를 **최대한 모아서 한번에 처리** 가능 (Batch 처리 효과) |
    | **트랜잭션 롤백 대비** | SQL을 미리 날리지 않으니, 롤백 시 쿼리를 취소할 수 있음                             |
    | **일관성 유지**     | flush 타이밍을 제어함으로써, DB와의 싱크 타이밍을 제어 가능                          |

    | 메서드        | 설명                                                 |
    | ---------- | -------------------------------------------------- |
    | `flush()`  | 쓰기 지연 저장소의 쿼리를 **즉시 DB에 반영**하지만, 트랜잭션은 유지됨         |
    | `commit()` | `flush()`를 먼저 수행한 뒤, 트랜잭션을 **종료하고 실제로 반영(Commit)** |

* 엔티티의 생명주기
    - 엔티티에는 4가지 상태가 존재한다

    | 상태  | 설명                           |
    | --- | ---------------------------- |
    | 비영속 | 아직 영속성 컨텍스트에 등록되지 않음         |
    | 영속  | 영속성 컨텍스트에 등록됨. JPA가 상태 관리    |
    | 준영속 | 더 이상 JPA가 관리하지 않음. DB 반영 X   |
    | 삭제  | 삭제 요청된 상태. flush 시 DELETE 발생 |

* 엔티티의 등록, 수정, 삭제
    - JPA에서 엔티티의 등록, 수정, 삭제는 각각 persist(), 변경감지, remove() 등의 메서드를 통해 처리된다 모두 영속성 컨텍스트를 중심으로 작동하며 트랜잭션 커밋 시점에서 SQL로 변환되어 DB에 저장된다

    1. 엔티티 등록
    - EntityManager.persist(entity)
        + 비영속 상태의 엔티티를 영속성 컨텍스트에 등록
        + 아직 DB에는 반영되지 않음 (쓰기 지연)
        + 트랜잭션 commit() 시 INSERT SQL 실행
        + 반드시 트랜잭션 안에서 호출해야 함
        + 같은 식별자를 가진 엔티티가 이미 존재하면 예외 발생
    ```java
    Member member = new Member("홍길동");
    em.persist(member);
    ```

    2. 엔티티 수정
    - 변경 감지(Dirty Checking)
        + EntityManager가 관리하는 영속 상태 엔티티의 필드가 변경되면 > 트랜잭션 커밋 시 JPA가 자동으로 변경을 감지해서 UPDATE SQL 생성
        + update() 같은 명시적 메서드는 없음
        + 반드시 영속 상태 엔티티여야 감지 가능 (비영속/준영속이면 감지 안됨)
    ```java
    Member member = em.find(Member.class, 1L);
    member.setName("강감찬"); // setter 호출

    // UPDATE SQL은 없지만 트랜잭션 커밋 시 자동 감지
    ```

    3. 엔티티 삭제
    - EntityManager.remove(entity);
        + 해당 엔티티는 삭제 대상 상태로 전환
        + 트랜잭션 커밋시 delete SQL 실행
        + remove() 호출 전, 해당 엔티티는 반드시 영속 상태여야 함(find()로 조회하거나 persist()된 상태)
    ```java
    Member member = em.find(Member.class, 1L);
    em.remove(member); // 삭제 예약
    ```

    | 작업 | 상태            | 메서드                     | SQL 실행 시점         |
    | -- | ------------- | ----------------------- | ----------------- |
    | 등록 | 비영속 → 영속      | `persist()`             | 트랜잭션 커밋 (flush 시) |
    | 수정 | 영속 상태에서 필드 변경 | setter + Dirty Checking | 트랜잭션 커밋           |
    | 삭제 | 영속 → 삭제 예약    | `remove()`              | 트랜잭션 커밋           |

* 플러시(flush)
    - 영속성 컨텍스트(1차 캐시)에 저장된 엔티티 변경사항을 SQL로 변환하여 DB에 저장하는 것(변경사항 DB 동기화)
        + 플러시를 실행하는 변경 감지가 동작하여 영속성 컨텍스트에 있는 모든 엔티티와 스냅샷을 비교하여 수정된 엔티티를 찾아 수정 쿼리를 만들어 쓰기 지연 저장소에 등록한다
        + 쓰기 지연 저장소에 등록된 쿼리를 DB에 전송한다

    ```java
    em.getTransaction().begin();

    Member member = new Member("홍길동");
    em.persist(member); // 1차 캐시에만 등록됨

    em.flush(); // 이 시점에 INSERT SQL 실행됨

    em.getTransaction().commit(); // flush는 이미 됐으므로 단순 커밋
    ```

    | 항목          | flush           | commit          |
    | ----------- | --------------- | --------------- |
    | 의미          | 변경 내용을 DB에 "반영" | 트랜잭션을 "종료"하고 커밋 |
    | 트랜잭션 종료 여부  | 안 함             | 함               |
    | 롤백 가능 여부    | 가능              | 불가능 (이미 반영됨)    |
    | 시점 제어 가능 여부 | 명시적 또는 자동       | 트랜잭션에 종속됨       |

    - 플러시 발생 시점
    | 시점                      | 설명                                                    |
    | ----------------------- | ----------------------------------------------------- |
    | 트랜잭션 커밋 시               | `em.getTransaction().commit()` 호출 시 자동 flush 후 commit |
    | JPQL, Criteria 쿼리 실행 직전 | SELECT 전에 flush로 DB와 동기화                              |
    | 명시적으로 `em.flush()` 호출 시 | 수동 flush (단, 커밋은 아님)                                  |
    > DB에 변경내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 수정사항이 반영되지 않는다 따라서 트랜잭션을 커밋하기 전 플러시를 호출하여 영속성 컨텍스트의 변경내용을 DB에 반영해야 한다 > JPA는 트랜잭션 커밋할 때 플러시를 자동으로 호출한다

    - 플러시가 필요한 이유
    | 이유         | 설명                                   |
    | ---------- | ------------------------------------ |
    | DB와 동기화    | 쿼리 실행 전에 DB 상태를 최신 상태로 맞춰야 정확한 결과 보장 |
    | 변경 추적 적용   | 영속성 컨텍스트 내 변경 사항을 실제 DB에 반영          |
    | 트랜잭션 격리 보장 | DB에 실제 반영을 미뤄야 롤백과 커밋이 정확하게 작동 가능    |

    - 플러시 모드<br/>
    영속성 컨텍스트의 변경 내용을 DB에 언제 반영할지 제어하는 모드, 읽기 전용 트랜잭션에서는 생략하기도 함

    | 옵션           | 설명                                      |
    | ------------ | --------------------------------------- |
    | `AUTO` (기본값) | 쿼리 실행(JPQL/Criteria 등) 직전에 자동으로 flush   |
    | `COMMIT`     | 트랜잭션을 커밋할 때만 flush. 쿼리 실행 전에는 flush 안 함 |

* 준영속
    - 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태라고 한다
    > 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

    | 방법                  | 설명                                 |
    | ------------------- | ---------------------------------- |
    | `em.detach(entity)` | 특정 엔티티만 준영속 상태로 전환                 |
    | `em.clear()`        | 모든 영속성 컨텍스트 초기화 → 모든 엔티티 준영속됨      |
    | `em.close()`        | EntityManager 종료 시 전체 준영속 상태       |
    | 트랜잭션 종료 후           | Spring에서는 트랜잭션 끝나면 자동으로 detach 처리됨 |

    - merge()로 준영속 상태의 엔티티를 영속 상태로 변환할 수 있다
        + 병합은 준영속, 비영속을 구별하지 않는다. 식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하고 조회가 불가능하면 새로 생성하여 병합을 진행한다
    ```java
    Member detachedMember = ... // 준영속 상태
    Member managedMember = em.merge(detachedMember); // 다시 영속 상태로

    managedMember.setName("이순신"); // 이건 반영됨
    ```
    > 준영속 상태의 값을 새 영속 엔티티에 복사하여 관리하는 방식이므로 리턴된 객체 managedMember를 사용해야 한다