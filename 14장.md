## 14장. 컬렉션과 부가기능

### 컬렉션
JPA는 자바에서 기본으로 제공하는 Collection, List, Set, Map 등 컬렉션을 지원한다
@OneToMany, @ManyToMany를 사용해서 일대다, 다대다 엔티티 관계를 매핑할 때
@ElementCollection을 사용하여 값 타입을 하나 이상 보관할 때
    
### JPA와 컬렉션
하이버네이트는 엔티티를 영속 상태로 만들 때, 컬렉션 필드를 하이버네이트에서 준비한 컬렉션으로 감싸서 사용한다
    
```java
@Entity
public class Team {
    @Id
    private String id;

    @OneToMany
    @JoinColumn
    private Collection<Member> members = new ArrayList<Member>();
}

Team team = new Team();
System.out.println(team.getMembers().getClass());
em.persist();
System.out.println(team.getMembers().getClass());

// class java.util.ArrayList
// class org.hibernate.collection.internal.PersistentBag
```
> 원래 ArrayList 타입이던 컬렉션이 엔티티를 영속상태로 만든 직후, 하이버네이트가 제공하는 PersistentBag 타입으로 변경되었다.  

하이버네이트는 컬렉션을 효율적으로 관리하기 위해서 엔티티를 영속 상태로 만들 때, 원본 컬렉션을 감싸고 있는 내장 컬렉션을 생성하고 이 내장 컬렉션을 사용하도록 참조를 변경한다.  
이러한 특징때문에 컬렉션을 사용할 때, 다음처럼 초기화하여 사용하는 것을 권장한다.

```java
Collection<Member> members = new ArrayList<Member>();
```

|컬렉션 인터페이스|내장 컬렉션|중복 허용|순서 보관|
|---|---|---|---|
|Collection, List|PersistentBag|O|X|
|Set|PersistentSet|X|X|
|List + @OrderColumn|PersistentList|O|O|

# Collection, List
    
+ Collection, List 인터페이스는 중복을 허용하는 컬렉션
+ PersistentBag을 래퍼 컬렉션으로 사용한다

```java
@OneToMany
@JoinColumn
private Collection<CollectionChild> collection = new ArrayList<CollectionChild>();

@OneToMany
@JoinColumn
private List<ListChild> list = new ArrayList<ListChild>();
```
> Collection과 List는 ArrayList로 초기화하여 사용한다

Collection과 List는 중복을 허용한다고 가정하므로 객체를 추가하는 add() 메소드는 항상 true를 리턴한다  
같은 엔티티를 찾거나 삭제할 때는 equals() 메소드를 사용한다
    
```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private List<Child> children = new ArrayList<>();
}

// 사용 예시
Parent parent = entityManager.find(Parent.class, 1L);
// 이 시점에서 children은 아직 초기화되지 않은 프록시 상태

Child newChild = new Child();
newChild.setParent(parent);
parent.getChildren().add(newChild); // 이 add() 연산은 DB 조회를 트리거하지 않음!

// 하지만 아래 연산들은 컬렉션을 초기화함 (DB 조회 발생)
int size = parent.getChildren().size();     // 초기화 필요
boolean isEmpty = parent.getChildren().isEmpty(); // 초기화 필요
for (Child child : parent.getChildren()) { ... }  // 초기화 필요
```
> 왜 add()는 컬렉션을 초기화하지 않을까?

1. 중복을 허용하여 기존 데이터와 비교할 필요가 없다
2. 그래서 단순히 새 엔티티만 컬렉션 끝에 추가하면 된다
3. DB에서 기존 데이터를 가져올 필요 없음!

### Set
Set은 중복을 허용하지 않는 컬렉션
PersistentSet을 래퍼 컬렉션으로 사용한다

```java
@OneToMany
@JoinColumn
private Set<SetChild> set = new HashSet<SetChild>();
```
> Set은 HashSet으로 초기화하여 사용한다

HashSet은 중복을 허용하지 않으므로 add() 메소드로 객체를 추가할 때마다 equals()로 같은 객체가 존재하는지 비교한다
+ 같은 객체가 존재하면 false, 같은 객체가 없으면 true
+ HashSet은 해시 알고리즘을 사용하므로 hashcode()도 사용하여 비교한다

```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private Set<Child> children = new HashSet<>();
}

// 사용 예시
Parent parent = entityManager.find(Parent.class, 1L);
// children은 아직 PersistentSet 프록시 상태

Child newChild = new Child();
newChild.setParent(parent);

parent.getChildren().add(newChild); 
// 이 순간 다음이 일어남:
// 1. DB에서 기존 Child들을 모두 로드 (SELECT 쿼리 실행!)
// 2. 프록시 -> 실제 HashSet으로 초기화
// 3. 기존 Child들과 newChild를 hashCode/equals로 비교
// 4. 중복이 아니면 HashSet에 추가
```

### List + @OrderColumn
List 인터페이스에 @OrderColumn을 추가하면 순서가 있는 특수한 컬렉션으로 인식한다
순서가 있다는 의미는 데이터베이스에 순서 값을 저장하여 조회할 때 사용한다는 의미
PersistentList를 래퍼 클래스로 사용한다

```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    @OrderColumn(name = "list_order") // 순서를 저장할 컬럼명 지정
    private List<Child> children = new ArrayList<>();
}

@Entity 
public class Child {
    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Parent parent;
    
    // list_order 컬럼이 자동으로 추가됨 (엔티티에는 필드 불필요)
}
```

```sql
CREATE TABLE child (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    parent_id BIGINT,
    list_order INTEGER  -- @OrderColumn으로 생성되는 컬럼
);
```

```java
Parent parent = new Parent();
Child child1 = new Child("첫번째");
Child child2 = new Child("두번째"); 
Child child3 = new Child("세번째");

parent.getChildren().add(child1); // list_order = 0
parent.getChildren().add(child2); // list_order = 1  
parent.getChildren().add(child3); // list_order = 2

entityManager.persist(parent);

// 조회할 때 자동으로 ORDER BY list_order로 정렬됨
Parent loaded = entityManager.find(Parent.class, parent.getId());
// children은 항상 추가한 순서대로 나옴
```

- 단점
    + 연관관계의 주인쪽에서 매핑하므로 자식은 list_order를 모름
        + 자식을 insert하면 list_order가 추가되지 않는다
    + 중간 삽입/삭제를 진행하면 여러 행의 list_order를 업데이트 해야한다
    + 데이터 불일치시 list_order가 NULL이 될 수 있다
        + child2를 삭제하면 list_order는 [0, 2]가 된다, 이 경우 list를 조회하면 1번 위치에 null이 보관되고 컬렉션을 순회하면 NPE이 발생한다

- 장점
    + 순서 보장
        + DB에서 조회해도 항상 같은 순서를 반환
    + 인덱스 접근
        + list.get(index) 사용가능
    + 중간 삽입/삭제도 순서 유지가능
        + 중간 삽입/삭제가 이루어지면 update 쿼리로 요소를 앞당기거나 뒤로 미루는 작업이 필요한데 이건 JPA에서 알아서 처리해준다

### @OrderBy
@OrderColumn이 데이터베이스에 순서용 컬럼(인덱스)를 매핑하여 관리했다면 @OrderBy는 데이터베이스의 ORDER BY절을 사용하여 컬렉션을 정렬한다(순서용 컬럼 매핑 필요 X)

```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent")
    @OrderBy("name ASC") // name 컬럼 기준 오름차순 정렬
    private List<Child> children = new ArrayList<>();
}

@Entity
public class Child {
    private String name;
    private LocalDateTime createdAt;
    @ManyToOne
    private Parent parent;
}

// 1. 단일 컬럼 정렬
@OrderBy("name ASC")
@OrderBy("createdAt DESC")

// 2. 복합 정렬
@OrderBy("name ASC, createdAt DESC")

// 3. 기본키로 정렬 (컬럼명 생략 시)
@OrderBy // id 기준 정렬 (기본값)
```
> @OrderBy의 값은 엔티티의 필드가 대상이다

@OrderBy와 @OrderColumn의 차이점

|구분|@OrderBy|@OrderColumn|
|---|---|---|
|정렬 기준|엔티티의 컬럼|별도의 순서 컬럼 생성|
|DB 변화|변화없음|list_order 컬럼 추가|
|성능|Select 시에만 Order By|중간 삽입/삭제 시 update|
|순서 변경|해당 컬럼 값 변경으로|List 조작으로|

### @OrderBy의 내부 동작
일반적으로 @OneToMany에서 Set을 사용하면 하이버네이트는 HashSet을 사용한다

```java
@OneToMany(mappedBy = "parent")
private Set<Child> children = new HashSet<>();

// 하이버네이트가 HashSet으로 초기화
// 순서 보장 안됨
```

하지만 @OrderBy를 사용하면 LinkedHashSet을 사용한다
```java
@OneToMany(mappedBy = "parent")
@OrderBy("name ASC")
private Set<Child> children = new HashSet<>(); // 선언은 HashSet이지만...

// 실제로는 LinkedHashSet으로 초기화됨!
```

이유는 HashSet의 문제점에 있다.
+ 해시 기반이라 삽입 순서와 조회 순서가 다르며
+ @OrderBy로 정렬해서 가져와도 Set 내부에서 순서가 섞인다

```java
// @OrderBy("name ASC")로 DB에서 정렬해서 가져옴
// DB 결과: [Alice, Bob, Charlie]

// HashSet에 넣으면 순서가 뒤섞임
// 실제 순서: [Charlie, Alice, Bob] (해시값에 따라)
```

따라서 삽입순서를 유지하는 LinkedHashSet으로 가져온다

```java
Parent parent = entityManager.find(Parent.class, 1L);
Set<Child> children = parent.getChildren();

System.out.println(children.getClass());
// @OrderBy 없음: class java.util.HashSet  
// @OrderBy 있음: class java.util.LinkedHashSet
```

### @Converter
컨버터는 엔티티의 속성과 DB 컬럼 간의 데이터 변환을 처리하는 애노테이션
아래와 같은 방식으로 사용할 수 있다

```java
// 1. Converter 클래스 작성
@Converter
public class BooleanToYNConverter implements AttributeConverter<Boolean, String> {
    
    @Override
    public String convertToDatabaseColumn(Boolean attribute) {
        return (attribute != null && attribute) ? "Y" : "N";
    }
    
    @Override
    public Boolean convertToEntityAttribute(String dbData) {
        return "Y".equals(dbData);
    }
}

// 2. 엔티티에서 사용
@Entity
public class User {
    @Convert(converter = BooleanToYNConverter.class)
    private Boolean isActive; // Java: Boolean <-> DB: VARCHAR('Y'/'N')
}
```

@Converter(autoApply = true) 옵션으로 모든 불린 타입에 대해 글로벌 적용이 가능하다

```java
@Converter(autoApply = true) // 모든 Boolean 타입에 자동 적용
public class BooleanToYNConverter implements AttributeConverter<Boolean, String> {
    // ...
}

// 이제 모든 Boolean 필드가 자동으로 Y/N으로 변환됨
@Entity
public class User {
    private Boolean isActive; // 자동으로 컨버터 적용
    private Boolean isDeleted; // 자동으로 컨버터 적용
}
```

다양한 변환 예시
+ Enum 변환
```java
public enum Status {
    ACTIVE("A"), INACTIVE("I"), PENDING("P");
    
    private String code;
    Status(String code) { this.code = code; }
    // getter, 정적 메서드 등...
}

@Converter
public class StatusConverter implements AttributeConverter<Status, String> {
    @Override
    public String convertToDatabaseColumn(Status attribute) {
        return attribute != null ? attribute.getCode() : null;
    }
    
    @Override
    public Status convertToEntityAttribute(String dbData) {
        return Status.fromCode(dbData);
    }
}
```

+ JSON 변환
```java
@Converter
public class JsonConverter implements AttributeConverter<Map<String, Object>, String> {
    private final ObjectMapper mapper = new ObjectMapper();
    
    @Override
    public String convertToDatabaseColumn(Map<String, Object> attribute) {
        try {
            return mapper.writeValueAsString(attribute);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    @Override
    public Map<String, Object> convertToEntityAttribute(String dbData) {
        try {
            return mapper.readValue(dbData, Map.class);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

@Entity
public class Product {
    @Convert(converter = JsonConverter.class)
    @Column(columnDefinition = "TEXT")
    private Map<String, Object> metadata; // Java: Map <-> DB: JSON String
}
```

+ 암호화 변환
```java
@Converter
public class EncryptionConverter implements AttributeConverter<String, String> {
    @Override
    public String convertToDatabaseColumn(String attribute) {
        return encrypt(attribute); // 암호화 로직
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        return decrypt(dbData); // 복호화 로직
    }
}

@Entity
public class User {
    @Convert(converter = EncryptionConverter.class)
    private String ssn; // 주민번호 암호화 저장
}
```

컬렉션에서도 사용이 가능하다
```java
@ElementCollection
@Convert(converter = StatusConverter.class)
private List<Status> statusHistory; // List의 각 요소에 컨버터 적용
```

### 리스너
JPA 리스너는 엔티티 생명주기에 따른 이벤트가 발생할 때, 자동으로 실행되는 콜백 메소드를 정의하는 기능이다

```
@PrePersist   // 엔티티가 영속화되기 직전
@PostPersist  // 엔티티가 영속화된 직후
@PreUpdate    // 엔티티가 업데이트되기 직전
@PostUpdate   // 엔티티가 업데이트된 직후
@PreRemove    // 엔티티가 삭제되기 직전
@PostRemove   // 엔티티가 삭제된 직후
@PostLoad     // 엔티티가 DB에서 조회된 직후
```

이벤트는 엔티티에서 직접 받거나 별도의 리스너를 등록하여 받을 수 있다

* 엔티티에 직접 적용
```java
@Entity
public class User {
    private Long id;
    private String name;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        System.out.println("새 사용자가 생성됩니다: " + name);
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
        System.out.println("사용자 정보가 업데이트됩니다: " + name);
    }
    
    @PostLoad
    protected void onLoad() {
        System.out.println("사용자 정보를 조회했습니다: " + name);
    }
}
```

* 별도의 리스너 클래스 사용
```java
// 리스너 클래스
public class AuditingEntityListener {
    
    @PrePersist
    public void prePersist(Object entity) {
        if (entity instanceof Auditable) {
            Auditable auditable = (Auditable) entity;
            auditable.setCreatedAt(LocalDateTime.now());
            auditable.setCreatedBy(getCurrentUser());
        }
    }
    
    @PreUpdate  
    public void preUpdate(Object entity) {
        if (entity instanceof Auditable) {
            Auditable auditable = (Auditable) entity;
            auditable.setUpdatedAt(LocalDateTime.now());
            auditable.setUpdatedBy(getCurrentUser());
        }
    }
    
    private String getCurrentUser() {
        // 현재 사용자 정보 조회 로직
        return SecurityContextHolder.getContext().getAuthentication().getName();
    }
}

// 공통 인터페이스
public interface Auditable {
    void setCreatedAt(LocalDateTime createdAt);
    void setCreatedBy(String createdBy);
    void setUpdatedAt(LocalDateTime updatedAt);
    void setUpdatedBy(String updatedBy);
}

// 엔티티에 리스너 적용
@Entity
@EntityListeners(AuditingEntityListener.class)
public class User implements Auditable {
    private String name;
    private LocalDateTime createdAt;
    private String createdBy;
    private LocalDateTime updatedAt;
    private String updatedBy;
    
    // getter/setter...
}
```

* 글로벌 리스너 등록
```java
// persistence.xml 또는 @Configuration에서 등록
@Configuration
public class JpaConfig {
    
    @EventListener
    public void configureJpa(ApplicationReadyEvent event) {
        // 모든 엔티티에 적용되는 글로벌 리스너
    }
}
```

여러 리스너를 등록했을 때, 이벤트 호출 순서는 다음고 같다
기본 리스너 > 부모 클래스 리스너 > 리스너 > 엔티티

스프링부트에서는 더 간편한 방법을 제공한다
```java
// Application 클래스에서 활성화
@SpringBootApplication
@EnableJpaAuditing
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// 베이스 엔티티 작성
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {
    
    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;
    
    @CreatedBy
    @Column(updatable = false)
    private String createdBy;
    
    @LastModifiedDate
    private LocalDateTime updatedAt;
    
    @LastModifiedBy
    private String updatedBy;
}

// 실제 엔티티
@Entity
public class User extends BaseEntity {
    private String name;
    private String email;
    // createdAt, updatedAt 등은 자동으로 관리됨
}
```

주요 활용 용도는
+ 감사 : 생성일시, 수정일시, 작성자 자동 기록
+ 로깅 : 데이터 변경 이력 추적
+ 데이터 검증 : 저장 전 유효성 검사
+ 이벤트 발행 : 도메인 이벤트 처리

리스너는 횡단 관심사를 깔끔하게 분리할 수 있는 방법이다.

### 엔티티 그래프
예를 들어, JPQL은 주문을 조회하는 쿼리여도 함께 조회할 엔티티에 따라 서로 다른 JPQL을 사용해야 한다
이것은 JPQL이 데이터를 조회하는 기능뿐만 아니라 연관된 엔티티를 함께 조회하는 기능도 제공하기 때문이다.
이럴 떄, 엔티티 그래프를 사용하여 어떤 연관관계를 함께 조회할지 동적으로 정의할 수 있다.

+ 일반적인 지연 로딩
```java
@Entity
public class Order {
    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;
    
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List<OrderItem> orderItems;
    
    @ManyToOne(fetch = FetchType.LAZY)  
    private Address deliveryAddress;
}

// 사용 시 N+1 문제 발생
List<Order> orders = entityManager.createQuery("SELECT o FROM Order o", Order.class)
    .getResultList();

for (Order order : orders) {
    System.out.println(order.getCustomer().getName());     // 추가 쿼리
    System.out.println(order.getOrderItems().size());     // 추가 쿼리
    System.out.println(order.getDeliveryAddress().getCity()); // 추가 쿼리
}
// 총 1 + 3N개의 쿼리 실행!
```

+ Named 엔티티 그래프
```java
@Entity
@NamedEntityGraph(
    name = "Order.withCustomerAndItems",
    attributeNodes = {
        @NamedAttributeNode("customer"),
        @NamedAttributeNode("orderItems"),
        @NamedAttributeNode("deliveryAddress")
    }
)
public class Order {
    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;
    
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List<OrderItem> orderItems;
    
    @ManyToOne(fetch = FetchType.LAZY)
    private Address deliveryAddress;
}

// EntityManager를 사용한 방법
EntityGraph<?> entityGraph = entityManager.getEntityGraph("Order.withCustomerAndItems");

List<Order> orders = entityManager.createQuery("SELECT o FROM Order o", Order.class)
    .setHint("javax.persistence.fetchgraph", entityGraph)
    .getResultList();

// 이제 한 번의 JOIN 쿼리로 모든 데이터 조회!
// SELECT o.*, c.*, oi.*, da.* FROM order o 
// LEFT JOIN customer c ON ... 
// LEFT JOIN order_item oi ON ... 
// LEFT JOIN address da ON ...
```

+ 동적 엔티티 그래프
```java
// 프로그래밍 방식으로 동적 생성
EntityGraph<Order> graph = entityManager.createEntityGraph(Order.class);
graph.addAttributeNodes("customer");
graph.addAttributeNodes("orderItems");

List<Order> orders = entityManager.createQuery("SELECT o FROM Order o", Order.class)
    .setHint("javax.persistence.fetchgraph", graph)
    .getResultList();
```

+ Fetch Graph와 Load Graph
```java
// FETCH: 그래프에 정의된 속성만 즉시 로딩, 나머지는 지연 로딩
.setHint("javax.persistence.fetchgraph", graph)

// LOAD: 그래프 속성 + 원래 EAGER 속성 모두 즉시 로딩  
.setHint("javax.persistence.loadgraph", graph)
```

+ ROOT에서 시작  
엔티티 그래프는 항상 조회하는 엔티티의 ROOT에서 시작해야 한다

+ 이미 로딩된 엔티티의 경우  
영속성 컨텍스트에 엔티티가 이미 로딩되어 있으면 엔티티 그래프가 적용되지 않는다