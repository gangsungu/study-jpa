## 16장. 트랜잭션과 락, 2차 캐시

### 트랜잭션 격리수준
트랜잭션은 ACID라 하는 4가지 속성을 보장해야 한다

+ 원자성(Atomicity)
    - 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다

+ 일관성(Consistency)
    - 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지해야 한다. 데이터베이스 무결성 제약 조건 등

+ 격리성(Isolation)
    - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 격리 수준을 선택할 수 있다

+ 지속성(Durability)
    - 트랜잭션을 성공적으로 끝내면 결과가 항상 기록되어야 한다. 시스템에 문제가 발생해도 데이터베이스 로드 등을 통해 성공한 트랜잭션 내용을 복구해야 한다

트랜잭션은 원자성, 일관성, 지속성을 보장한다.  
문제는 격리성인데, 트랜잭션 간의 격리성을 완벽하게 보장하려면 순서대로 트랜잭션을 실행해야 한다.  
그럼 동시성 처리 능력이 너무 떨어지므로 트랜잭션의 격리수준을 4단계로 나누어 사용한다.

|격리수준|Dirty Read|Non-repeatable Read|Phantom Read|
|---|---|---|---|
|READ UNCOMMITTED (커밋되지 않은 읽기)|O|O|O|
|READ COMMITED (커밋된 읽기)||O|O|
|REPEATABLE READ (반복 가능한 읽기)|||O|
|SERIALIZABLE (직렬화 가능)||||

+ READ UNCOMMITTED  
다른 트랜잭션의 커밋하지 않은 데이터도 읽을 수 있다  
트랜잭션 1이 데이터를 수정하고 있는데, 커밋하지 않았어도 트랜잭션2가 읽을 수 있다(Dirty Read)  
트랜잭션 2가 Dirty Read한 데이터를 사용하는데, 트랜잭션 1이 롤백하면 데이터 정합성에 문제가 발생할 수 있다

+ READ COMMITTED  
커밋한 데이터만 읽을 수 있다. 따라서 Dirty Read가 발생하지 않는다  
트랜잭션 1이 회원 A를 조회 중인데, 트랜잭션 2가 회원 A를 조회하고 커밋하면  
트랜잭션 1이 다시 회원 A를 조회했을 때 
수정된 데이터가 조회된다(Non-Repeatable Read)

+ REPEATABLE READ  
한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다 하지만 Phantom Read도 발생할 수 있다  
트랜잭션 1이 10살 이하 회원을 조회했는데, 트랜잭션 2가 5살 회원을 추가하고 커밋하면  
트랜잭션 1이 다시 10살 이하 회원을 조회했을 때, 회원 하나가 추가된 상태로 조회된다.(Phantom Read)

+ SERIALIZABLE  
가장 엄격한 트랜잭션 격리 수준, 트랜잭션이 순차적으로 실행된다

### 낙관적 락과 비관적 락  
JPA의 영속성 컨텍스트(1차 캐시)를 활용하면 트랜잭션이 READ COMMITTED여도 REPEATABLE READ가 가능하다.  
1차 캐시는 같은 트랜잭션 내라면 반복 가능한 읽기를 보장하기 때문이다.  
물론, 엔티티가 아닌 스칼라 값을 조회하면 영속성 컨텍스트의 관리를 받지못하므로 반복가능한 읽기가 불가능하다.

+ 낙관적 락
    - 트랜잭션 충돌이 발생하지 않는다고 가정한다
    - 데이터베이스에서 제공하는 락 기능을 사용하는 것이 아닌 JPA에서 사용하는 버전 관리 기능을 사용
    - 낙관적 락은 트랜잭션을 커밋하기 전까지 트랜잭션의 충돌을 알 수 없다

+ 비관적 락
    - 트랜잭션 충돌이 무조건 발생한다고 가정하고 락을 미리 걸어둔다
    - 데이터베이스에서 제공하는 락을 사용한다(for update 문)
    
+ lost update
    - 두개 이상의 트랜잭션이 같은 데이터를 동시에 수정할 때, 한 트랜잭션의 변경사항이 다른 트랜잭션에 의해 덮어씌워지는 현상

    ```
    초기 계좌 잔액: 1000원

    시간 | 트랜잭션 A (출금 500원)    | 트랜잭션 B (입금 300원)
    -----|---------------------------|-------------------------
    T1   | READ balance = 1000       |
    T2   |                           | READ balance = 1000
    T3   | balance = 1000 - 500 = 500|
    T4   |                           | balance = 1000 + 300 = 1300
    T5   | WRITE balance = 500       |
    T6   |                           | WRITE balance = 1300

    결과: 최종 잔액 1300원 (트랜잭션 A의 출금이 손실됨)
    올바른 결과: 800원 (1000 - 500 + 300)
    ```

    - 해결방법
        - 마지막 커밋만 인정하기 : 마지막에 커밋한 트랜잭션 B만 반영한다(디폴트)
        - 최초 커밋만 인정하기 : 트랜잭션 A가 이미 수정을 완료했으므로 트랜잭션 B는 오류를 발생시킨다
        - 충돌하는 커밋 병합 : 트랜잭션 A와 트랜잭션 B를 병합

+ @Version
    - JPA에서 낙관적 락을 구현하기 위한 핵심 요소
    - 엔티티의 버전을 관리하는 필드에 설정하는 애노테이션으로 JPA가 자동으로 동시성 제어를 수행하도록 함
        + Long (long), Integer (int), Short (short), Timestamp에 설정가능
        
        ```java
        @Entity
        public class Product {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
            
            private String name;
            private Integer stock;
            
            @Version  // 버전 필드
            private Long version;
            
            // 생성자, getter, setter...
        }
        ```

    - 버전 필드 자동 관리
    ```java
    // 엔티티 생성 시
    Product product = new Product("상품명", 100);
    productRepository.save(product);
    // SQL: INSERT INTO product (name, stock, version) VALUES ('상품명', 100, 0)
    // version은 자동으로 0으로 설정됨
    ```

    - 업데이트시 버전 체크
    ```java
    @Transactional
    public void updateProduct(Long productId, String newName) {
        Product product = productRepository.findById(productId).get();
        // product.version = 0 (현재 버전)
        
        product.setName(newName);
        productRepository.save(product);
        
        // 생성되는 SQL:
        // UPDATE product SET name = ?, version = ? WHERE id = ? AND version = ?
        // UPDATE product SET name = 'new name', version = 1 WHERE id = 1 AND version = 0
    }
    ```

    - 동시 수정시 예외 발생
    ```java
    // 시나리오: 두 트랜잭션이 동시에 같은 엔티티를 수정
    // 트랜잭션 A
    Product productA = productRepository.findById(1L).get(); // version = 0
    productA.setName("상품A");

    // 트랜잭션 B  
    Product productB = productRepository.findById(1L).get(); // version = 0
    productB.setName("상품B");

    // 트랜잭션 A 커밋 성공
    productRepository.save(productA); // version 0 -> 1로 변경

    // 트랜잭션 B 커밋 시도
    productRepository.save(productB); // OptimisticLockException 발생!
    // WHERE version = 0 조건에 맞는 행이 없음 (이미 version = 1)
    ```
    
    - 버전 필드 직접 수정 금지
    - 연관관계 필드는 연관관계의 주인 필드를 수정할 때만 버전이 증가한다
    - 벌크 업데이트는 영속성 컨텍스트를 거쳐 업데이트하는 것이 아니므로 버전 필드를 수동으로 증가시켜야 한다
        - 영속성 컨텍스트를 clear()하여 최신 데이터 반영이 필요

+ JPA 락
    - 동시성 제어를 위한 방법으로 여러 트랜잭션이 동시에 같은 데이터에 접근할 때, 데이터 무결성을 보장하기 위해 사용됨

    | 락 모드 | 락 종류 | @Version 필요 | 다른 트랜잭션 읽기 | 다른 트랜잭션 쓰기 | 락 획득 시점 | 성능 |
    |---------|---------|---------------|-------------------|-------------------|--------------|------|
    | **OPTIMISTIC** | 낙관적 | 필수 | 허용 | 허용 (충돌 시 예외) | 커밋 시점 | 높음 |
    | **OPTIMISTIC_FORCE_INCREMENT** | 낙관적 | 필수 | 허용 | 허용 (충돌 시 예외) | 커밋 시점 | 높음 |
    | **PESSIMISTIC_READ** | 비관적 | 선택적 | 허용 | 차단 | 즉시 | 중간 |
    | **PESSIMISTIC_WRITE** | 비관적 | 선택적 | 차단 | 차단 | 즉시 | 낮음 |
    | **PESSIMISTIC_FORCE_INCREMENT** | 비관적 | 필수 | 차단 | 차단 | 즉시 | 낮음 |

    - 낙관적 락
        - JPA가 제공하는 낙관적 락은 @Version을 사용한다
        - 낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 발생시킨다
        - 락 옵션이 없이 @Version만 있어도 낙관적 락이 적용된다

        - NONE
            - 조회한 엔티티를 수정할 때, 다른 트랜잭션에 의해 변경(삭제)되지 않아야 한다. 조회 시점부터 수정 시점까지 보장
            - 엔티티를 수정할 때, 버전을 체크하면서 버전을 증가한다
            - Lost Update 문제 예방가능

        - OPTIMISTIC  
            - @Version은 엔티티를 수정해야 버전을 체크하지만 이 옵션을 추가하면 엔티티를 조회만 해도 버전을 체크한다
            - 한번 조회한 엔티티는 트랜잭션을 종료할 떄까지 변경되지 않음을 보장
            - 트랜잭션을 커밋할 때, 버전 정보를 조회해서 현재 엔티티의 버전과 같은지 확인, 다르면 예외 발생
            - Dirty Read와 Non-Repeatable Read를 방지

        - OPTIMISTIC_FORCE_INCREMENT
            - 논리적인 단위의 엔티티 묶음을 관리할 수 있다
                - 게시물과 첨부파일의 관계, 첨부파일만 추가되면 게시물의 버전은 증가하지 않는다. 하지만 논리적으로는 게시물이 수정된 것이므로 해당 옵션을 추가하면 게시물의 버전도 증가한다
            - 엔티티를 수정하지 않아도 트랜잭션을 커밋할 때, UPDATE 쿼리를 사용해 버전 정보를 증가시칸다
            - 트랜잭션을 커밋할 떄, 버전정보가 증가하므로 엔티티를 수정하는 경우, 버전 정보가 두번 증가할 수 있다

    - 비관적 락
        - JPA가 제공하는 비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존한다
        - 주로 SQL 쿼리에 for update 구문을 사용하여 적용하며 버전 정보는 사용하지 않는다
        - 엔티티가 아닌 스칼라 타입을 조회할 때도 사용가능
        - 데이터를 수정하는 즉시 트랜잭션 충돌을 감지가능

        - PESSIMISTIC_WRITE
            - 데이터베이스에 select for update를 사용하여 락을 건다
            - Non-Repeatable Read를 방지한다, 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다

        - PESSIMISTIC_READ
            - 데이터를 반복읽기만 수정해고 수정하지 않는 용도로 락을 걸때 사용

        - PESSIMISTIC_FORCE_INCREMENT
            - 비관적 락 중 유일하게 버전 정보를 사용한다

        - 비관적 락을 사용하면 락을 획득할 때까지 트랜잭션이 대기한다 무한정 대기할 수 없으므로 타임아웃 시간을 설정할 수 있다

    | 시나리오 | 권장 락 모드 | 이유 |
    |----------|-------------|------|
    | **읽기 작업이 많은 환경** | OPTIMISTIC | 읽기 성능에 영향 없음 |
    | **충돌이 드문 업데이트** | OPTIMISTIC | 높은 성능, 간단한 구현 |
    | **충돌이 빈번한 업데이트** | PESSIMISTIC_WRITE | 확실한 동시성 제어 |
    | **재고 관리 시스템** | PESSIMISTIC_WRITE | 데이터 정확성 보장 |
    | **계좌 이체** | PESSIMISTIC_WRITE | 금융 데이터 무결성 |
    | **조회 시 데이터 일관성 필요** | PESSIMISTIC_READ | 읽는 동안 수정 방지 |
    | **연관 엔티티 변경 감지** | OPTIMISTIC_FORCE_INCREMENT | 간접 변경도 버전 증가 |


    | 락 모드 | 발생 가능한 예외 | 원인 | 처리 방법 |
    |---------|------------------|------|-----------|
    | **OPTIMISTIC** | OptimisticLockException | 다른 트랜잭션이 먼저 수정 | 재시도 로직 구현 |
    | **PESSIMISTIC** | LockTimeoutException | 락 획득 시간 초과 | 타임아웃 시간 조정, 사용자 알림 |
    | **PESSIMISTIC** | PessimisticLockException | 락 획득 실패 | 재시도 또는 다른 전략 |
    | **ALL** | DeadlockLoserDataAccessException | 데드락 발생 | 일관된 락 순서, 재시도 |

### 2차 캐시
1차 캐시는 영속성 컨텍스트 내부에 있다. 엔티티 매니저로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장된다  
이후, 트랜잭션을 커밋하거나 플러시를 호출하면 1차 캐시에 있는 엔티티의 변경 내역을 데이터베이스에 반영한다

+ 1차 캐시의 특징
    - 1차 캐시는 같은 엔티티가 있으면 해당 엔티티를 그대로 반환한다
        - 1차 캐시는 객체 동일성을 보장
    - 1차 캐시는 영속성 컨텍스트 범위의 캐시다

2차 캐시는 우리가 흔히 이야기하는 애플리케이션 레벨의 캐시다(애플리케이션이 종료될 때까지 유지)  
2차 캐시를 적용하면 엔티티 매니저를 통해 데이터를 조회할 때, 2차 캐시에서 찾고 없으면 데이터베이스에서 찾는다

```
1차 캐시 (영속성 컨텍스트) → 2차 캐시 → 데이터베이스
```

+ 2차 캐시의 특징
    - 영속성 유닛 범위의 캐시
    - 조회한 객체를 그대로 반환하는 것이 아닌 객체를 복사해서 반환
    - 2차 캐시는 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 동일성을 보장하지 않음

+ 캐시 모드 설정
    - 엔티티에 @Cacheable 선언
        - @Cacheable(true), @Cacheable(false)를 선언할 수 있는데 true가 기본 값

+ 캐시 동시성 전략
    - NONE
        - 캐시를 설정하지 않는다

    - READ_ONLY
        - 캐시를 읽기 전용으로 설정, 등록과 삭제는 가능하지만 수정은 불가능하다  
        읽기 전용인 불변 객체는 수정되지 않으므로 하이버네이트는 2차 캐시를 조회할 때, 복사한 객체가 아닌 원본 객체를 반환한다

        ```java
        @Entity
        @Cacheable
        @Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
        public class Country {
            @Id
            private String code;
            
            private String name;
            
            // 읽기 전용 데이터 (수정되지 않는 마스터 데이터)
        }
        ```

    - READ_WRITE
        - 읽기와 쓰기가 가능하고 REAC COMMITTED의 격리 수준을 보장한다

        ```java
        @Entity
        @Cacheable
        @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
        public class User {
            @Id
            private Long id;
            
            private String name;
            private String email;
            
            // 읽기/쓰기 모두 가능한 일반적인 데이터
        }
        ```

    - NONSTRICT_READ_WRITE
        - 엄격하지 않은 쓰기 전략, 동시에 같은 엔티티를 수정하면 데이터 일관성이 깨질 우려가 있다

        ```java
        @Entity
        @Cacheable
        @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
        public class Category {
            @Id
            private Long id;
            
            private String name;
            
            // 가끔 업데이트되는 데이터 (엄격한 일관성 불필요)
        }
        ```

    - TRANSACTIONAL
        - 컨테이너 관리 환경에서 사용가능, 설정에 따라 REPEATABLE READ의 격리 수준을 보장받을 수 있다

        ```java
        @Entity
        @Cacheable
        @Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL)
        public class BankAccount {
            @Id
            private Long id;
            
            private BigDecimal balance;
            
            // 트랜잭션 지원이 필요한 중요한 데이터
        }
        ```